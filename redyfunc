CREATE OR REPLACE FUNCTION api.get_cities(country_id INTEGER) RETURNS TABLE (identifier INTEGER, description CHARACTER VARYING(50)) AS $$
BEGIN
    RETURN QUERY
    SELECT city.identifier, city.description
    FROM data.city
    WHERE data.city.country = country_id;
END;
$$ LANGUAGE plpgsql;
//////2
CREATE OR REPLACE FUNCTION api.get_city_location() RETURNS TABLE (identifier INTEGER, latitude DOUBLE PRECISION, longitude DOUBLE PRECISION) AS $$
BEGIN
    RETURN QUERY
    SELECT city.identifier, city.latitude, city.longitude
    FROM data.city;
END;
$$ LANGUAGE plpgsql;
/////4
CREATE OR REPLACE FUNCTION api.get_countries(region_id INTEGER) RETURNS TABLE (identifier INTEGER, description CHARACTER VARYING) AS $$
BEGIN
    RETURN QUERY
    SELECT data.country.identifier, data.country.description
    FROM data.country
    INNER JOIN data.region ON data.country.region = data.region.identifier
    WHERE data.region.identifier = region_id;
END;
$$ LANGUAGE plpgsql;
//////5
CREATE OR REPLACE FUNCTION api.get_country_cities_count()
RETURNS TABLE (identifier INTEGER, countries INTEGER) AS $$
BEGIN
    RETURN QUERY
    SELECT data.city.country, COUNT(*)::INTEGER AS city_count
    FROM data.city
    GROUP BY data.city.country;
END;
$$ LANGUAGE plpgsql;
///////6
CREATE OR REPLACE FUNCTION api.get_daily_temperature(city_id INTEGER, start_date DATE, end_date DATE)
RETURNS TABLE (ts TIMESTAMP WITHOUT TIME ZONE, temperature DOUBLE PRECISION) AS $$
BEGIN
    RETURN QUERY
    SELECT data.measurement.mark, data.measurement.temperature
    FROM data.measurement
    WHERE city = city_id
        AND mark >= start_date
        AND mark <= end_date;
END;
$$ LANGUAGE plpgsql;
//////7
CREATE OR REPLACE FUNCTION api.get_daily_temperature_reduce(city_id INTEGER, start_date DATE, end_date DATE, num_values INTEGER)
RETURNS TABLE (unix_ts TIMESTAMP WITHOUT TIME ZONE, average_temperature DOUBLE PRECISION) AS $$
BEGIN
    RETURN QUERY
    SELECT mark, AVG(temperature) AS average_temperature
    FROM data.measurement
    WHERE city = city_id
        AND mark >= start_date
        AND mark <= end_date
    GROUP BY mark
    ORDER BY mark
    LIMIT num_values;
END;
$$ LANGUAGE plpgsql;
//////8
CREATE OR REPLACE FUNCTION api.get_measurement_time_range(city_id INTEGER)
RETURNS TABLE (earliest_date TIMESTAMP WITHOUT TIME ZONE, latest_date TIMESTAMP WITHOUT TIME ZONE) AS $$
BEGIN
    RETURN QUERY
    SELECT MIN(data.measurement.mark) AS earliest_date, MAX(data.measurement.mark) AS latest_date
    FROM data.measurement
    WHERE city_id = city_id;
END;
$$ LANGUAGE plpgsql;
